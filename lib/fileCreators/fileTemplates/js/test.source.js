"use strict";

const capitalize = require("../../../utils/capitalize");
const { randomName, randomDate, randomNumber } = require("../../../seedData/seed.data");

exports.editableTestSource = (asset, options) => `"use strict";

const mongoose = require("mongoose");
const ${capitalize(asset)} = require("../../../../api/v${
  options.apiv
}/models/${asset}/${asset}.model");

//Require the dev-dependencies
const chai = require("chai"); // should matchers etc.
const chaiHttp = require("chai-http"); // request().get() ...
const dotEnv = require("dotenv");
// make variables available from .env locally
dotEnv.config();
const server = require("../../../../server"); // your app
${options.auth ? `const { getAccessToken } = require("../../utils");` : ""}

// set up
const should = chai.should();
chai.use(chaiHttp);

// NOTE: using arrow functions as mocha functions is discouraged, thus function() is used!
describe("[CUSTOM TEST] ${capitalize(asset)} asset endpoints\\n", function() {
  this.timeout(10000);


  ${
    options.auth
      ? `// UNCOMMENT THE CODE BLOCK BELOW IF YOU WANT ACCESS TO AUTH0 AUTHORIZATION TOKEN

  // let access_token = "";

  // before(async function() {
  //   // runs before all tests in this block

  //   // get auth0 token for accessing api
  //   access_token = await getAccessToken();
  // });`
      : ""
  }

  beforeEach(function(done) {
    //Before each test empty the database and start clean
    ${capitalize(asset)}.deleteMany({}, err => {
      done();
    });
  });

  describe("<HTTP_VERB_HERE> /api/v${options.apiv}/${asset}", function() {
    it("it should be your test case here", function() {
      // ... your test
      const dummy_sum = 1+1;
      dummy_sum.should.equal(2);
    });
  });
});
`;

exports.generatedTestSource = (asset, options, model) => {
  let testCases = "";
  if (model) {
    testCasesArray.forEach(testCaseGenerator => {
      testCases += testCaseGenerator(asset, options, model);
    });
  }

  return `"use strict";

// DO NOT MODIFY THIS TEST!

// These test are generated by Sapphire from the JSON backed model schemas. Every
// time a new asset gets created, or an existing asset gets modified, the tests
// are regenerated from scratch. Thus any tests written here by hand may be lost!
  
// If youâ€™d like to add more tests, even to the same asset, please use the
// ${asset}Custom.test.js in 'custom' tests folder

const mongoose = require("mongoose");
const ${capitalize(asset)} = require("../../../../api/v1/models/${asset}/${asset}.model");

//Require the dev-dependencies
const chai = require("chai"); // should matchers etc.
const chaiHttp = require("chai-http"); // request().get() ...
const dotEnv = require("dotenv");
// make variables available from .env locally
dotEnv.config();
const server = require("../../../../server"); // your app
${options.auth ? `const { getAccessToken } = require("../../utils");` : ""}

// set up
const should = chai.should();
chai.use(chaiHttp);

// NOTE: using arrow functions as mocha functions is discouraged, thus function() is used!
describe("[SAPPHIRE TEST] ${capitalize(asset)} asset endpoints\\n", function() {
  this.timeout(10000);

  ${
    options.auth
      ? `let access_token = "";

  before(async function() {
    // runs before all tests in this block

    // get auth0 token for accessing api
    access_token = await getAccessToken();
  });`
      : ""
  }

  beforeEach(function(done) {
    //Before each test empty the database and start clean
    ${capitalize(asset)}.deleteMany({}, err => {
      done();
    });
  });

  // SAPPHIRE TEST CASE GENERATION WIP....
  ${testCases}
});
`;
};

function generateTestCaseGET(asset, options, model) {
  const { saveFields, saveFieldsObject } = generateSaveFields(asset, model);
  const shouldTests = generateShouldLines(saveFieldsObject, 12);

  return `describe("GET /${asset}", function() {
    it("it should get all the ${capitalize(asset)}", function(done) {
      chai
        .request(server)
        .get("/api/v${options.apiv}/${asset}")
        .end((err, res) => {
          res.should.have.status(200);
          res.body.should.be.a("array");
          res.body.length.should.be.eql(0);
          done();
        });
    });
  });

  describe("GET /${asset}/:id", () => {
    it("it should GET ${capitalize(asset)} by the given id", done => {
      let ${asset} = new ${capitalize(asset)}(${saveFields});
      ${asset}.save((err, ${asset}) => {
        chai
          .request(server)
          .get(\`/api/v${options.apiv}/${asset}/\${${asset}.id}\`)
          .send(${asset})
          .end((err, res) => {
            res.should.have.status(200);
            res.body.should.be.a("object");
            ${shouldTests}
            res.body.should.have.property("_id").eql(${asset}.id);
            done();
          });
      });
    });
  });
  `;
}

function generateTestCasePOST(asset, options, model) {
  // let negativeTest = `it("it should not POST a ${capitalize(asset)} without pages field", done => {
  //     let ${asset} = {
  //       title: "The Lord of the Rings",
  //       author: "J.R.R. Tolkien",
  //       year: 1954
  //     };
  //     chai
  //       .request(server)
  //       .post("/api/v${options.apiv}/${asset}")
  //       ${options.auth ? `.set("Authorization", \`Bearer \${access_token}\`)` : ""}
  //       .send(${asset})
  //       .end((err, res) => {
  //         res.should.have.status(200);
  //         res.body.should.be.a("object");
  //         res.body.should.have.property("errors");
  //         res.body.errors.should.have.property("pages");
  //         res.body.errors.pages.should.have.property("kind").eql("required");
  //         done();
  //       });
  //   });
  // `;

  let negativeTest = ""; // MVP. core features first...

  const { saveFields, saveFieldsObject } = generateSaveFields(asset, model);
  const shouldTests = generateShouldLines(saveFieldsObject, 10);

  let positiveTest = `it("it should POST a ${asset} ", done => {
      let ${asset} = ${saveFields};
      chai
        .request(server)
        .post("/api/v${options.apiv}/${asset}")
        ${options.auth ? `.set("Authorization", \`Bearer \${access_token}\`)` : ""}
        .send(${asset})
        .end((err, res) => {
          res.should.have.status(200);
          res.body.should.be.a("object");
          ${shouldTests}
          done();
        });
    });
  `;

  let combinedTest = `
  describe("POST /${asset}", () => {
    ${negativeTest}
    ${positiveTest}
  });
    `;
  return combinedTest;
}

function generateTestCasePUT(asset, options, model) {
  return `
  describe("PUT /${asset}/:id", () => {
    it("it should UPDATE a ${asset} given the id", done => {
      let ${asset} = new ${capitalize(asset)}({
        title: "The Chronicles of Narnia",
        author: "C.S. Lewis",
        year: 1948,
        pages: 778
      });
      ${asset}.save((err, ${asset}) => {
        chai
          .request(server)
          .put(\`/api/v${options.apiv}/${asset}/\${${asset}.id}\`)
          ${options.auth ? `.set("Authorization", \`Bearer \${access_token}\`)` : ""}
          .send({ title: "The Chronicles of Narnia", author: "C.S. Lewis", year: 1950, pages: 778 })
          .end((err, res) => {
            res.should.have.status(200);
            res.body.should.be.a("object");
            res.body.should.have.property("message").eql("${capitalize(asset)} updated!");
            res.body.${asset}.should.have.property("year").eql(1950);
            done();
          });
      });
    });
  });
  `;
}

function generateTestCaseDELETE(asset, options, model) {
  const { saveFields } = generateSaveFields(asset, model);

  return `
  describe("DELETE /${asset}/:id", () => {
    it("it should DELETE a ${capitalize(asset)} given the id", done => {
      let ${asset} = new ${capitalize(asset)}(${saveFields});
      ${asset}.save((err, ${asset}) => {
        chai
          .request(server)
          .delete(\`/api/v${options.apiv}/${asset}/\${${asset}.id}\`)
          ${options.auth ? `.set("Authorization", \`Bearer \${access_token}\`)` : ""}
          .end((err, res) => {
            res.should.have.status(200);
            res.body.should.be.a("object");
            res.body.should.have.property("message").eql("${asset} successfully deleted");
            res.body.result.should.have.property("ok").eql(1);
            res.body.result.should.have.property("n").eql(1);
            res.body.result.should.have.property("deletedCount").eql(1);
            done();
          });
      });
    });
  });
  `;
}

let testCasesArray = [];
testCasesArray.push(generateTestCaseGET);
testCasesArray.push(generateTestCasePOST);
// testCasesArray.push(generateTestCasePUT);
testCasesArray.push(generateTestCaseDELETE);

function generateSaveFields(asset, originalModel) {
  // little trick to deep copy javascript object...
  let model = JSON.parse(JSON.stringify(originalModel));

  let saveFieldsObject = {};
  let rawSaveFieldsString = "";
  let saveFields = "";

  saveFieldsObject = generatePopulatedModelObject(asset, model);

  // process the string to fit into the code section
  rawSaveFieldsString = JSON.stringify(saveFieldsObject, null, 2);

  // add different indentation levels to different lines
  const lines = rawSaveFieldsString.split(/\r?\n/);
  for (let i = 0, line = ""; i < lines.length; i++) {
    line = lines[i];
    if (i === 0) line = `${line}\n`;
    else if (i === lines.length - 1) line = `\t\t\t${line}`;
    else line = `\t\t\t${line}\n`;

    saveFields += line;
  }

  return { saveFields, saveFieldsObject };
}

function generateShouldLines(saveFieldsObject, indent) {
  let finalShouldLinesString = `// not exhaustive, but pretty comprehensive test...`;

  let indentSpace = "";
  for (let i = 0; i < indent; i++) indentSpace += " ";

  for (let field in saveFieldsObject) {
    finalShouldLinesString += `
${indentSpace}${generateTestLine(field, saveFieldsObject)}`;
  }

  return finalShouldLinesString;
}

function generateTestLine(field, saveFieldsObject) {
  let basicTest = `res.body.should.have.property("${field}")`;
  let extraCheck = `${
    saveFieldsObject[field] ? `.eql(${JSON.stringify(saveFieldsObject[field])})` : ""
  }`;

  const testLine = `${basicTest}${extraCheck};`;
  return testLine;
}

function generatePopulatedModelObject(asset, model) {
  // base case
  if (model.type) return assignValueToField(asset, model);

  // recursive case
  for (let field in model) {
    if (field === "createdDate" || field === "auth") delete model[field];
    else model[field] = generatePopulatedModelObject(asset, model[field]);
  }

  return model;
}

function assignValueToField(asset, field, fieldof) {
  // TODO: handle schema types & the type options

  // TODO: long term, road map feature. Implement semantic field population
  // based on field type and name.
  // e.g. 'name':'String' <- Ernest
  // e.g. 'car':'String' <- Tesla
  // e.g. 'age':'Number' <- 45 ... (value between 1 and 100)
  // etc.
  // this will be powered by a predefined bank of knowledge about typical
  // types and their expected values. This will be accumulated over time.

  // TODO: fix the issue where the field has to be defined as
  // "name" : {"type": "String"}
  // and allow to optionally define the field as
  // "name" : "String"

  // // mongoose documentation
  // // var schema = new Schema({
  //   mixed:   Schema.Types.Mixed, [WIP]
  //   _someId: Schema.Types.ObjectId, [WIP]
  //   decimal: Schema.Types.Decimal128, [WIP] not supported yet???

  // // example use

  // var Thing = mongoose.model('Thing', schema);

  // var m = new Thing;
  // m.mixed = { any: { thing: 'i want' } };
  // m.markModified('mixed'); /// DEAL WITH THIS !!!!

  // m._someId = new mongoose.Types.ObjectId;

  // m.save(callback);

  // TODO: multi doc references
  // "book" : { "type": "mongoose.Schema.ObjectId", "ref": "Book" }    .... 1:1
  // "books" : [{ "type": "mongoose.Schema.ObjectId", "ref": "Book" }] .... 1:m or n:m

  let value = "";

  // if fieldof is given, then Map generator is using this function (edgecase).
  // otherwise generatePopulatedModelObject is using this function (regular case).
  let type = fieldof ? fieldof : field.type;

  switch (type) {
    // basic types
    case "String":
      value = generateString(field);
      break;
    case "Date":
      value = generateDate(field);
      break;
    case "Number":
      value = generateNumber(field);
      break;
    case "Boolean":
      value = generateBoolean(field);
      break;
    case "Buffer":
      value = generateBuffer(field);
      break;
    case "Map":
      value = generateMap(asset, field);
      break;
    // mixed types
    case "Schema.Types.Mixed":
    case "mongoose.Mixed":
    case "Object":
    case "{}":
      value = generateMixed(field);
      break;
    // Array types
    // 1D array generators
    case "[Date]":
      value = generateArray(field, generateDate);
      break;
    case "[{}]":
    case "[Schema.Types.Mixed]":
      value = generateArray(field, generateMixed);
      break;
    case "[String]":
      value = generateArray(field, generateString);
      break;
    case "[Number]":
      value = generateArray(field, generateNumber);
      break;
    case "[Buffer]":
      value = generateArray(field, generateBuffer);
      break;
    case "[Boolean]":
      value = generateArray(field, generateBoolean);
      break;
    case "[]":
    case "Array":
    case "[Schema.Types.ObjectId]":
    case "[mongoose.Schema.ObjectId]":
      value = generateArray(field);
      break;
    // 2D array generators
    case "[[]]":
      value = generateArray(field, generateArray);
      break;
    case "[[Date]]":
      value = generateArray(field, generateArray, generateDate);
      break;
    case "[[{}]]":
    case "[[Schema.Types.Mixed]]":
      value = generateArray(field, generateArray, generateMixed);
      break;
    case "[[String]]":
      value = generateArray(field, generateArray, generateString);
      break;
    case "[[Number]]":
      value = generateArray(field, generateArray, generateNumber);
      break;
    case "[[Buffer]]":
      value = generateArray(field, generateArray, generateBuffer);
      break;
    case "[[Boolean]]":
      value = generateArray(field, generateArray, generateBoolean);
      break;
    // 3D array generators
    case "[[[]]]":
      value = generateArray(field, generateArray, generateArray);
      break;
    // currently unsupported types
    case "mongoose.Schema.ObjectId":
    case "Schema.Types.ObjectId":
    // break; // currently unsupported, let it fall through
    case "Schema.Types.Decimal128":
    // break; // currently unsupported, let it fall through
    default:
      if (!field.hasOwnProperty("required")) {
        console.log(`
  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  WARNING: Unrecognised or unsupported field type: ${type}
  
  Model: ${asset}
  
  As this field is not marked as 'required' Sapphire will proceed with test
  generation for this model, but will NOT include this type in tests!
  
  If you want to test this type, please write custom tests for this model.
  
  NOTE: This field type may be supported in future version of Sapphire.
  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  `);
      } else {
        throw {
          message: "unsupported_field_type",
          type: type,
          asset: asset,
          required: field.hasOwnProperty("required")
        };
      }
  }

  return value;
}

function generateString(field) {
  if (field.hasOwnProperty("default")) return; // let mongoose default handler handle it
  if (field.hasOwnProperty("enum")) return generateEnumValue(field);

  let returnString = randomName();

  if (returnString.length < field.minlength) {
    const diff = field.minlength - returnString.length;
    for (let i = 0; i < diff; i++) returnString += "_";
  } else if (field.maxlength) returnString = returnString.slice(0, field.maxlength);
  return returnString;
}

function generateDate(field) {
  if (field.hasOwnProperty("default")) return; // let mongoose default handler handle it
  return randomDate();
}

function generateNumber(field) {
  if (field.hasOwnProperty("default")) return; // let mongoose default handler handle it
  return randomNumber(field.max || 400000000, field.min);
}

function generateBoolean(field) {
  if (field.hasOwnProperty("default")) return; // let mongoose default handler handle it
  return 1 == randomNumber(2);
}

function generateBuffer(field) {
  if (field.hasOwnProperty("default")) return; // let mongoose default handler handle it

  // mongoose docs:
  // Mongoose will successfully cast the below values to buffers.
  // const file1 = new Data({ binData: "test" }); // {"type":"Buffer","data":[116,101,115,116]}
  // const file2 = new Data({ binData: 72987 }); // {"type":"Buffer","data":[27]}
  // const file4 = new Data({ binData: { type: "Buffer", data: [1, 2, 3] } }); // {"type":"Buffer","data":[1,2,3]}
  return randomName();
}

function generateMixed(field) {
  // TODO: need to markModified before changes can be detected before save???!?!?!

  if (field.hasOwnProperty("default")) return; // let mongoose default handler handle it
  return { anyhting: { goes: "here" } };
}

function generateMap(asset, field) {
  if (field.hasOwnProperty("of")) return generateMapOf(asset, field);
  return { key1: "value1", key2: "value2" };
}

function generateArray(field, generator, innerGenerator) {
  let array = [];
  if (generator) {
    const length = randomNumber(6, 3);
    for (let i = 0; i < length; i++) {
      if (!innerGenerator) array.push(generator(field));
      else array.push(generateArray(field, innerGenerator));
    }
  }

  // mongoose docs:

  // Arrays are special because they implicitly have a default value of [] (empty array).
  // var ToyBox = mongoose.model("ToyBox", ToyBoxSchema);
  // console.log(new ToyBox().toys); // []

  return array; // just do what mongoose would do by default
}

function generateMapOf(asset, field) {
  const value1 = assignValueToField(asset, field, field.of);
  const value2 = assignValueToField(asset, field, field.of);
  return { key1: value1, key2: value2 };
}

function convertStrToJavascript(string) {
  return new Function(`return ${string}`)();
}

function generateDefaultValue(field) {
  if (Array.prototype.isPrototypeOf(field.default)) return field.default[0];

  try {
    return convertStrToJavascript(field.default)();
  } catch (err) {
    return field.default;
  }
}

function generateEnumValue(field) {
  const randIndex = Math.floor(Math.random() * field.enum.length);
  return field.enum[randIndex];
}
