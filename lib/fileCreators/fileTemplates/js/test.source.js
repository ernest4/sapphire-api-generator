"use strict";

const capitalize = require("../../../utils/capitalize");
const { randomName } = require("../../../seedData/seeds");

exports.editableTestSource = (asset, options) => `"use strict";

const mongoose = require("mongoose");
const ${capitalize(asset)} = require("../../../../api/v${
  options.apiv
}/models/${asset}/${asset}.model");

//Require the dev-dependencies
const chai = require("chai"); // should matchers etc.
const chaiHttp = require("chai-http"); // request().get() ...
const dotEnv = require("dotenv");
// make variables available from .env locally
dotEnv.config();
const server = require("../../../../server"); // your app
${options.auth ? `const { getAccessToken } = require("../../utils");` : ""}

// set up
const should = chai.should();
chai.use(chaiHttp);

// NOTE: using arrow functions as mocha functions is discouraged, thus function() is used!
describe("[CUSTOM TEST] ${capitalize(asset)} asset endpoints\\n", function() {
  this.timeout(10000);


  ${
    options.auth
      ? `// UNCOMMENT THE CODE BLOCK BELOW IF YOU WANT ACCESS TO AUTH0 AUTHORIZATION TOKEN

  // let access_token = "";

  // before(async function() {
  //   // runs before all tests in this block

  //   // get auth0 token for accessing api
  //   access_token = await getAccessToken();
  // });`
      : ""
  }

  beforeEach(function(done) {
    //Before each test empty the database and start clean
    ${capitalize(asset)}.deleteMany({}, err => {
      done();
    });
  });

  describe("<HTTP_VERB_HERE> /api/v${options.apiv}/${asset}", function() {
    it("it should be your test case here", function() {
      // ... your test
      const dummy_sum = 1+1;
      dummy_sum.should.equal(2);
    });
  });
});
`;

exports.generatedTestSource = (asset, options, model) => {
  let testCases = "";
  if (model) {
    console.log(asset);
    console.log(options);
    console.log(model);

    testCasesArray.forEach(testCaseGenerator => {
      testCases += testCaseGenerator(asset, options, model);
    });
  }

  return `"use strict";

// DO NOT MODIFY THIS TEST!

// These test are generated by Sapphire from the JSON backed model schemas. Every
// time a new asset gets created, or an existing asset gets modified, the tests
// are regenerated from scratch. Thus any tests written here by hand may be lost!
  
// If youâ€™d like to add more tests, even to the same asset, please use the
// ${asset}Custom.test.js in 'custom' tests folder

const mongoose = require("mongoose");
const ${capitalize(asset)} = require("../../../../api/v1/models/${asset}/${asset}.model");

//Require the dev-dependencies
const chai = require("chai"); // should matchers etc.
const chaiHttp = require("chai-http"); // request().get() ...
const dotEnv = require("dotenv");
// make variables available from .env locally
dotEnv.config();
const server = require("../../../../server"); // your app
${options.auth ? `const { getAccessToken } = require("../../utils");` : ""}

// set up
const should = chai.should();
chai.use(chaiHttp);

// NOTE: using arrow functions as mocha functions is discouraged, thus function() is used!
describe("[SAPPHIRE TEST] ${capitalize(asset)} asset endpoints\\n", function() {
  this.timeout(10000);

  ${
    options.auth
      ? `let access_token = "";

  before(async function() {
    // runs before all tests in this block

    // get auth0 token for accessing api
    access_token = await getAccessToken();
  });`
      : ""
  }

  beforeEach(function(done) {
    //Before each test empty the database and start clean
    ${capitalize(asset)}.deleteMany({}, err => {
      done();
    });
  });

  // SAPPHIRE TEST CASE GENERATION WIP....
  ${testCases}
});
`;
};

function generateTestCaseGET(asset, options, model) {
  const saveFields = generateSaveFields(model);

  return `describe("GET /${asset}", function() {
    it("it should get all the ${capitalize(asset)}", function(done) {
      chai
        .request(server)
        .get("/api/v${options.apiv}/${asset}")
        .end((err, res) => {
          res.should.have.status(200);
          res.body.should.be.a("array");
          res.body.length.should.be.eql(0);
          done();
        });
    });
  });

  describe("GET /${asset}/:id", () => {
    it("it should GET ${capitalize(asset)} by the given id", done => {
      let ${asset} = new ${capitalize(asset)}(${saveFields});
      ${asset}.save((err, ${asset}) => {
        chai
          .request(server)
          .get(\`/api/v${options.apiv}/${asset}/\${${asset}.id}\`)
          .send(${asset})
          .end((err, res) => {
            res.should.have.status(200);
            res.body.should.be.a("object");
            res.body.should.have.property("title");
            res.body.should.have.property("author");
            res.body.should.have.property("pages");
            res.body.should.have.property("year");
            res.body.should.have.property("_id").eql(${asset}.id);
            done();
          });
      });
    });
  });
  `;
}

function generateTestCasePOST(asset, options, model) {
  return `
  describe("/POST ${asset}", () => {
    it("it should not POST a ${capitalize(asset)} without pages field", done => {
      let ${asset} = {
        title: "The Lord of the Rings",
        author: "J.R.R. Tolkien",
        year: 1954
      };
      chai
        .request(server)
        .post("/api/v${options.apiv}/${asset}")
        .send(${asset})
        .end((err, res) => {
          res.should.have.status(200);
          res.body.should.be.a("object");
          res.body.should.have.property("errors");
          res.body.errors.should.have.property("pages");
          res.body.errors.pages.should.have.property("kind").eql("required");
          done();
        });
    });
    it("it should POST a ${asset} ", done => {
      let ${asset} = {
        title: "The Lord of the Rings",
        author: "J.R.R. Tolkien",
        year: 1954,
        pages: 1170
      };
      chai
        .request(server)
        .post("/api/v${options.apiv}/${asset}")
        .send(${asset})
        .end((err, res) => {
          res.should.have.status(200);
          res.body.should.be.a("object");
          res.body.should.have.property("message").eql("${asset} successfully added!");
          res.body.${asset}.should.have.property("title");
          res.body.${asset}.should.have.property("author");
          res.body.${asset}.should.have.property("pages");
          res.body.${asset}.should.have.property("year");
          done();
        });
    });
  });
  `;
}

function generateTestCasePUT(asset, options, model) {
  return `
  describe("PUT /${asset}/:id", () => {
    it("it should UPDATE a ${asset} given the id", done => {
      let ${asset} = new ${capitalize(asset)}({
        title: "The Chronicles of Narnia",
        author: "C.S. Lewis",
        year: 1948,
        pages: 778
      });
      ${asset}.save((err, ${asset}) => {
        chai
          .request(server)
          .put(\`/api/v${options.apiv}/${asset}/\${${asset}.id}\`)
          .send({ title: "The Chronicles of Narnia", author: "C.S. Lewis", year: 1950, pages: 778 })
          .end((err, res) => {
            res.should.have.status(200);
            res.body.should.be.a("object");
            res.body.should.have.property("message").eql("${capitalize(asset)} updated!");
            res.body.${asset}.should.have.property("year").eql(1950);
            done();
          });
      });
    });
  });
  `;
}

function generateTestCaseDELETE(asset, options, model) {
  return `
  describe("DELETE /${asset}/:id", () => {
    it("it should DELETE a ${capitalize(asset)} given the id", done => {
      let ${asset} = new ${capitalize(asset)}({
        socialId : 'abcdefghijklmnop',
        name: {
          first: 'Ernest',
          last: 'Monkevicius'
        },
        gender: 'm',
        birthday: 1555355185541
      });
      ${asset}.save((err, ${asset}) => {
        chai
          .request(server)
          .delete(\`/api/v${options.apiv}/${asset}/\${${asset}.id}\`)
          .end((err, res) => {
            res.should.have.status(200);
            res.body.should.be.a("object");
            res.body.should.have.property("message").eql("${capitalize(
              asset
            )} successfully deleted!");
            res.body.result.should.have.property("ok").eql(1);
            res.body.result.should.have.property("n").eql(1);
            done();
          });
      });
    });
  });
  `;
}

let testCasesArray = [];
testCasesArray.push(generateTestCaseGET);
testCasesArray.push(generateTestCasePOST);
testCasesArray.push(generateTestCasePUT);
testCasesArray.push(generateTestCaseDELETE);

function generateSaveFields(model) {
  let saveFieldsObject = {};
  let rawSaveFieldsString = "";
  let finalSaveFieldsString = "";

  saveFieldsObject = generatePopulatedModelObject(model);

  // process the string to fit into the code section
  rawSaveFieldsString = JSON.stringify(saveFieldsObject, null, 2);

  const lines = rawSaveFieldsString.split(/\r?\n/);
  for (let i = 0, line = ""; i < lines.length; i++) {
    line = lines[i];
    console.log(line);
    if (i === 0) line = `${line}\n`;
    else if (i === lines.length - 1) line = `\t\t\t${line}`;
    else line = `\t\t\t${line}\n`;

    finalSaveFieldsString += line;
  }

  return finalSaveFieldsString;
}

function generatePopulatedModelObject(model) {
  // base case
  if (model.type) return assignValueToField(model);

  // recursive case
  for (let field in model) {
    if (field === "createdDate" || field === "auth") delete model[field];
    else model[field] = generatePopulatedModelObject(model[field]);
  }

  return model;
}

function assignValueToField(field) {
  // TODO: handle schema types & the type options

  // TODO: use random seed data to populate string fields...

  // TODO: fix the issue where the field has to be defined as
  // "name" : {"type": "String"}
  // and allow to optionally define the field as
  // "name" : "String"

  // mongoose documentation
  // var schema = new Schema({
  //   name:    String, [WIP]
  //   binary:  Buffer, [WIP]
  //   living:  Boolean, [WIP]
  //   updated: { type: Date, default: Date.now }, [WIP]
  //   age:     { type: Number, min: 18, max: 65 }, [WIP]
  //   mixed:   Schema.Types.Mixed, [WIP]
  //   _someId: Schema.Types.ObjectId, [WIP]
  //   decimal: Schema.Types.Decimal128, [WIP]

  //   array: [], [WIP]
  //   ofString: [String], [falls under general array processing]
  //   ofNumber: [Number], [falls under general array processing]
  //   ofDates: [Date], [falls under general array processing]
  //   ofBuffer: [Buffer], [falls under general array processing]
  //   ofBoolean: [Boolean], [falls under general array processing]
  //   ofMixed: [Schema.Types.Mixed], [falls under general array processing]
  //   ofObjectId: [Schema.Types.ObjectId], [falls under general array processing]
  //   ofArrays: [[]], [falls under general array processing]
  //   ofArrayOfNumbers: [[Number]], [falls under general array processing]

  //   nested: {
  //     stuff: { type: String, lowercase: true, trim: true }
  //   },

  //   map: Map, [WIP]
  //   mapOfString: { [not sure what to do here yet...]
  //     type: Map,
  //     of: String
  //   }
  // })

  // // example use

  // var Thing = mongoose.model('Thing', schema);

  // var m = new Thing;
  // m.name = 'Statue of Liberty';
  // m.age = 125;
  // m.updated = new Date;
  // m.binary = Buffer.alloc(0);
  // m.living = false;
  // m.mixed = { any: { thing: 'i want' } };
  // m.markModified('mixed');
  // m._someId = new mongoose.Types.ObjectId;
  // m.array.push(1);
  // m.ofString.push("strings!");
  // m.ofNumber.unshift(1,2,3,4);
  // m.ofDates.addToSet(new Date);
  // m.ofBuffer.pop();
  // m.ofMixed = [1, [], 'three', { four: 5 }];
  // m.nested.stuff = 'good';
  // m.map = new Map([['key', 'value']]);
  // m.save(callback);

  let value = "";
  let type = field.type;

  // if (field.default) {
  //   value = field.default;
  // } else {
  //   value = field.type;
  // }

  switch (type) {
    case "String":
      value = generateString(field);
      break;
    case "Date":
      // console.log("date");
      value = "date!";
      break;
    case "Number":
      // console.log("number");
      value = "number!";
      break;
    case "Boolean":
      // console.log("boolean");
      value = "boolean!";
      break;
    case "Buffer":
      // console.log("buffer");
      value = "buffer!";
    // break; // currently unsupported, let it fall through
    case "Map":
      // console.log("map");
      value = "map!";
    // break; // currently unsupported, let it fall through
    case "Schema.Types.Mixed":
      // console.log("schema.types.mixed");
      value = "schema.types.mixed!";
    // break; // currently unsupported, let it fall through
    case "Schema.Types.ObjectId":
      // console.log("schema.types.objectId");
      value = "schema.types.objectId!";
    // break; // currently unsupported, let it fall through
    case "Schema.Types.Decimal128":
      // console.log("schema.types.decimal128");
      value = "schema.types.decimal128!";
    // break; // currently unsupported, let it fall through
    default:
      console.log(`
      FAILED: Unrecognised or unsupported field type: ${type}
      
      Aborting test creation please write custom tests for this model!
      
      NOTE: This field type may be supported in future version of Sapphire.`);
      process.exit(1);

    // TODO: deal with arrays types....

    // if (type.match(/^\[/)) value = "array type with some or none content types!";
    // else value = "default! no type matched or type is currently unsupported";
  }

  return value;
}

function generateString(field) {
  let returnString = randomName();

  if (field.enum) {
    const randIndex = Math.floor(Math.random() * field.enum.length);
    return field.enum[randIndex];
  }

  if (returnString.length < field.minlength) {
    const diff = field.minlength - returnString.length;
    for (let i = 0; i < diff; i++) returnString += "_";
  } else if (field.maxlength) returnString = returnString.slice(0, field.maxlength);
  return returnString;
}
